package db_client;

import java.sql.CallableStatement;
import java.util.LinkedList;
import java.util.Queue;

import core_objects.pair;
import core_objects.stiki_utils.SCORE_SYS;

/**
 * Andrew G. West - qmanager_client.java - This class wraps all [queue_*] 
 * stored procedures implemented by STiki, and provides single 
 * methods to call them concurrently, where nedded. For example, choosing to
 * ignore an RID in one queue, should also set the ignore property in all 
 * others. A similar semantic governs the reservation system.
 * This particular version is specific to CLIENT-side operation.
 */
public class qmanager_client{
	
	// **************************** PRIVATE FIELDS ***************************
	
	/**
	 * Persistent connection to the STiki server (limited permissions).
	 */
	private stiki_con_client con_client;
	
	/**
	 * SQL call fetching a reservation of edits from the "Cluebot-NG" queue.
	 */
	private CallableStatement cstmt_queue_fetch_cbng;
	
	/**
	 * SQL call fetching a reservation of edits from the "STiki" queue.
	 */
	private CallableStatement cstmt_queue_fetch_stiki;
	
	/**
	 * SQL call fetching a reservation of edits from the "WikiTrust" queue.
	 */
	private CallableStatement cstmt_queue_fetch_wt;
	
	/**
	 * SQL call fetching a reservation of edits from the "Link Spam" queue.
	 */
	private CallableStatement cstmt_queue_fetch_spam;
	
	/**
	 * SQL call removing an edit from a shared revision queue.
	 */
	private CallableStatement cstmt_queue_delete;
	
	/**
	 * SQL call indicating a user wants to "ignore" classifying some edit.
	 */
	private CallableStatement cstmt_queue_ignore;
	
	/**
	 * SQL call to "resurrect" RIDs if INNOCENT->PASS reclassification is
	 * performed as a result of using the "back" button.
	 */
	private CallableStatement cstmt_queue_resurrect;
	
	/**
	 * SQL call releasing a reservation (e.g., on program exit).
	 */
	private CallableStatement cstmt_queue_wipe;
	
	
	// ***************************** CONSTRUCTORS ****************************
	
	/**
	 * Construct a "queue manager" for the client GUI.
	 * @param con Connection to STiki servers (limited privileges)
	 */
	public qmanager_client(stiki_con_client con_client) throws Exception{
		this.con_client = con_client;
		prep_statements();
	}
	
	
	// **************************** PUBLIC METHODS ***************************
	
		// Note: Of all the CLIENT-SIDE queue maintenance calls, ONLY the
		// "fetch" one requires that a specific queue be mentioned (so it
		// knows which ordering to use as the basis for the reservation). 
		// However, even this call cascades to other queues (the RID is
		// marked as reserved in all queues).
		//
		// ALL other methods are applicable to ALL queues. A removal from
		// one queue is equivalent to a removal for all others. Despite 
		// slightly variant backend processing times, this seems like a 
		// reasonable semantic on the CLIENT-SIDE. Implementation of "all"
		// is handled by SQL in the stored procedures themselves.
	
	/**
	 * Get (and temporarily reserve) a set of edits to classify. As a side
	 * effect, a reservation of duration [RESERVATION_TTL_SECS] is placed
	 * on each RID returned by this method (in ALL queues). Users should 
	 * not see revisions which they have previously ignored/passed.
	 * @param sys Queue (table name) whose scoring should be basis for fetch
	 * @param user Wiki-login or IP address of the STiki user, so that
	 * they will not be queued edits which they have previously passed/ignored
	 * @param res_id A numerical identifier for the reservation, presumably
	 * should be randomly generated by the client.
	 * @return A queue of edits. Each element in the array is a pair, whose 
	 * first element is an RID in need of classification,and the second element 
	 * is the P_ID (article) on which the edit resides.
	 */
	public synchronized Queue<pair<Long,Long>> queue_fetch(SCORE_SYS sys,
			String user, long res_id) throws Exception{
		
		String csv_queue = "";
		if(sys.equals(SCORE_SYS.CBNG)){
			cstmt_queue_fetch_cbng.setString(1, user);
			cstmt_queue_fetch_cbng.setLong(2, res_id);
			cstmt_queue_fetch_cbng.execute();
			csv_queue = cstmt_queue_fetch_cbng.getString(3);
		} else if(sys.equals(SCORE_SYS.STIKI)){
			cstmt_queue_fetch_stiki.setString(1, user);
			cstmt_queue_fetch_stiki.setLong(2, res_id);
			cstmt_queue_fetch_stiki.execute();
			csv_queue = cstmt_queue_fetch_stiki.getString(3);
		} else if(sys.equals(SCORE_SYS.WT)){
			cstmt_queue_fetch_wt.setString(1, user);
			cstmt_queue_fetch_wt.setLong(2, res_id);
			cstmt_queue_fetch_wt.execute();
			csv_queue = cstmt_queue_fetch_wt.getString(3);
		} else if(sys.equals(SCORE_SYS.SPAM)){
			cstmt_queue_fetch_spam.setString(1, user);
			cstmt_queue_fetch_spam.setLong(2, res_id);
			cstmt_queue_fetch_spam.execute();
			csv_queue = cstmt_queue_fetch_spam.getString(3);
		} // Make the stored procedure call (table specific), get output
			
			// Trim trailing comma, assume well-formedness of the 
			// SQL output: {pid,rid,pid,rid....}
		csv_queue = csv_queue.substring(0, csv_queue.length()-1);
		String[] csv_parts = csv_queue.split(",");
		Queue<pair<Long,Long>> queue = new LinkedList<pair<Long,Long>>();
		for(int i=0; i < csv_parts.length; i+=2)
			queue.offer(new pair<Long,Long>(Long.parseLong(csv_parts[i]), 
					Long.parseLong(csv_parts[i+1])));
		return(queue);
	}
	
	/**
	 * Remove an RID from all queues (e.g., if it was classified).
	 * @param rid Revision-ID whose row should be deleted (if present).
	 */
	public synchronized void queue_delete(long rid) 
			throws Exception{
		cstmt_queue_delete.setLong(1, rid);
		cstmt_queue_delete.execute();
	}
	
	/**
	 * "Resurrect" an RID, placing a previously classified RID back in all
	 * queues, as may be required per use of the "back" button. If necessary,
	 * remove the [feedback] recorded at initial classification.
	 * @param rid Revision identififier of RID to be resurrected
	 * @param pid Page identififier of RID to be resurrected
	 */
	public synchronized void queue_resurrect(long rid, long pid) 
			throws Exception{
		cstmt_queue_resurrect.setLong(1, rid);
		cstmt_queue_resurrect.setLong(2, pid);
		cstmt_queue_resurrect.execute();
	}
	
	/**
	 * Mark a particular edit as being 'ignored' by some user, making it such
	 * that they will not be presented the edit in again in the future. This
	 * should hold regardless of what edit queue they are using.
	 * @param rid Revision-ID of revision being marked as ignored
	 * @param user User who should never again see revision 'rid'
	 */
	public synchronized void queue_ignore(long rid, String user) 
			throws Exception{
		cstmt_queue_ignore.setLong(1, rid);
		cstmt_queue_ignore.setString(2, user);
		cstmt_queue_ignore.execute();
	}
	
	/**
	 * Release all edits in some reservation (which have not yet been
	 * classified), so that that they can be picked up by other clients.
	 * @param res_id Reservation ID of original reservation request
	 */
	public synchronized void queue_wipe(long res_id) throws Exception{
		cstmt_queue_wipe.setLong(1, res_id);
		cstmt_queue_wipe.execute();
	}
		
	/**
	 * Shutdown all objects created by this class (DB handlers). 
	 */
	public void shutdown() throws Exception{
		cstmt_queue_delete.close();
		cstmt_queue_fetch_cbng.close();
		cstmt_queue_fetch_stiki.close();
		cstmt_queue_fetch_wt.close();
		cstmt_queue_fetch_spam.close();
		cstmt_queue_ignore.close();
		cstmt_queue_resurrect.close();
		cstmt_queue_wipe.close();
	}
	
	
	// *************************** PRIVATE METHODS ***************************
	
	/**
	 * Prepare the databse (stored procedure) calls to be used by this class.
	 */
	private void prep_statements() throws Exception{
		
		cstmt_queue_fetch_cbng = con_client.con.prepareCall(
			"{CALL client_queue_fetch_cbng(?,?,?)}"); // 2 IN, 1 OUT params
		cstmt_queue_fetch_cbng.registerOutParameter(3, java.sql.Types.VARCHAR);
		
		cstmt_queue_fetch_stiki = con_client.con.prepareCall(
			"{CALL client_queue_fetch_stiki(?,?,?)}"); // 2 IN, 1 OUT params
		cstmt_queue_fetch_stiki.registerOutParameter(3, java.sql.Types.VARCHAR);
		
		cstmt_queue_fetch_wt = con_client.con.prepareCall(
			"{CALL client_queue_fetch_wt(?,?,?)}"); // 2 IN, 1 OUT params
		cstmt_queue_fetch_wt.registerOutParameter(3, java.sql.Types.VARCHAR);	
		
		cstmt_queue_fetch_spam = con_client.con.prepareCall(
			"{CALL client_queue_fetch_spam(?,?,?)}"); // 2 IN, 1 OUT params
		cstmt_queue_fetch_spam.registerOutParameter(3, java.sql.Types.VARCHAR);
		
		cstmt_queue_delete = con_client.con.prepareCall(
			"{CALL client_queue_delete(?)}"); // 1 IN param
		
		cstmt_queue_ignore = con_client.con.prepareCall(
			"{CALL client_queue_ignore(?,?)}"); // 2 IN params
		
		cstmt_queue_resurrect = con_client.con.prepareCall(
			"{CALL client_queue_resurrect(?,?)}"); // 2 IN params
		
		cstmt_queue_wipe = con_client.con.prepareCall(
			"{CALL client_queue_wipe(?)}"); // 1 IN param
	}

}
